{"data":{"markdownRemark":{"frontmatter":{"title":"量化系统的技术指标","date":"03 February 2017","path":"/technical-indicators-in-quant-system","author":null,"excerpt":null,"tags":["Design"],"coverImage":null},"id":"913bed2b-eacf-53da-a82d-12bc91c9f50a","html":"<blockquote>\n<p>技术指标泛指一切通过数学公式计算得出的源于<strong>市场数据</strong>的<strong>数据集合</strong>。</p>\n</blockquote>\n<p>这表明技术指标(Technical Indicator)最终都来源于市场数据；技术指标所谓的技术(Technique)就是指数学公式；技术指标的表现方式是数据的集合。</p>\n<p>市场数据实际上基本可以表述为市场价格的<strong>集合</strong>。</p>\n<p>从单笔交易这个微观的层面上看就是成交的价格与成交的量，这是一个瞬时值；</p>\n<p>从一段时间上又可以将复数的交易信息合并起来，形成开、高、低、收四种价格以及总成交量。</p>\n<p>整合这些信息，通过数学公式可以得到一个新的数据集合，称为<strong>技术指标</strong>。</p>\n<!--more-->\n<h1>设计问题</h1>\n<p>最初，技术指标的设计实现都是相当简单的，通常是写一个函数便可。</p>\n<p>例如森破移动平均线(Simple Moving Average)，通常只实现一个函数，然后将市场数据与时间周期参数传入：</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public class SimpleMA {\n  public static double calc(IReadOnlyList&lt;double&gt; data, int period) {\n    return data.AsEnumerable().Reverse().Take(period).Average();\n  }\n}</code></pre></div>\n<blockquote>\n<p>以上实现有严重的性能缺陷，并不建议使用。</p>\n<p>原因在于 IEnumerable 的 Reverse 方法对于 List 的随机访问没有做优化。</p>\n</blockquote>\n<p>这样去实现一个指标会有若干问题：</p>\n<ul>\n<li>\n<p>每一次引用指标都要重新做计算，计算性能不足。</p>\n<p>分析：可以用<strong>缓存指标值</strong>的方法来解决。因为技术指标是通过数学公式得出的，因此具有纯函数的性质，对于相同的输入，其输出一定相同——这就特别适合缓存了。</p>\n</li>\n<li>\n<p>缓存指标值由谁管理？</p>\n<p>分析：有如下设计方案</p>\n<ol>\n<li>保持技术指标的纯度，在技术指标的外部保存缓存，而保持技术指标内部无状态。</li>\n</ol>\n<p> 优点是正确性可以通过数学分析来保证。</p>\n<p> 缺点是内部状态缺失会导致对外的状态依赖增多。（引用指标将变得很繁琐）</p>\n<ol start=\"2\">\n<li>在指标内部维护状态，暴露必要的缓存的只读引用。</li>\n</ol>\n<p> 优点是引用指标简洁明快，指标计算效率高。</p>\n<p> 缺点是不同的指标性质不一，导致指标接口高度抽象。</p>\n<p>总体上来说，<strong>在指标内部维护状态</strong>是一个好的设计，隐藏指标的实现会降低系统的耦合度，提高指标的内聚性。</p>\n</li>\n<li>\n<p>指标需要维护哪些状态？</p>\n<p>分析：首先考虑指标的在线计算，要在正确的前提下，尽量减少指标的计算量。其次考虑到外部对指标历史值的引用，要暴露一个对历史数据的只读引用。</p>\n<ul>\n<li>指标内部需要维护图形吗？</li>\n</ul>\n<p>分析：不需要。因为技术指标是数据集合，与其表现方式无关。尽管每种指标都有其特定的惯用图形表示，但实际上图形与图形容器是强关联。</p>\n</li>\n<li>\n<p>如何编写指标能使之适应不同周期的数据？</p>\n<p>分析：订阅不同周期的外部数据事件即可，总体上是一个<strong>观察者模式</strong>。若外部环境没有提供合适的数据，可以利用<strong>适配器模式</strong>来构造合适的数据。</p>\n</li>\n</ul>\n<h1>解决方案</h1>\n<p>利用泛型接口来定义技术指标类：</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">public interface ITechnicalIndicator&lt;I, O&gt; {\n  void OnInput (object sender, I data);\n  event EventHandler&lt;O&gt; OnOutput;\n  IReadOnlyList&lt;O&gt; History { get; }\n}</code></pre></div>\n<p>现在让我们来造一个简单平均线指标：</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">using System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace TechnicalIndicators {\n    public class SimpleMovingAverage : ITechnicalIndicator&lt;double, double&gt; {\n        public SimpleMovingAverage(int period) {\n            if (period &lt; 1) {\n                throw new Exception(&quot;均线周期不能小于 1&quot;);\n            }\n            ArgPeriod = period;\n        }\n        public IReadOnlyList&lt;double&gt; History {\n            get {\n                return bufHistory;\n            }\n        }\n\n        public event EventHandler&lt;double&gt; OnOutput;\n\n        public void OnInput (object sender, double data) {\n            bufData.Add(data);\n            double sum = 0;\n            int total = Math.Min(bufData.Count, ArgPeriod);\n            for (int i = 0; i &lt; total; i++) {\n                sum += bufData[bufData.Count - i - 1];\n            }\n            bufHistory.Add(sum / total);\n            OnOutput?.Invoke(this, bufHistory.Last());\n        }\n        private List&lt;double&gt; bufData = new List&lt;double&gt;();\n        private List&lt;double&gt; bufHistory = new List&lt;double&gt;();\n        private int ArgPeriod;\n    }\n}</code></pre></div>\n<p>可以看到这个指标并不依赖于其他第三方库。</p>\n<p>在其他地方如何引用这个指标呢？只需要简单的按参数构造指标实例、订阅数据源即可。发布指标数据是一个可选事件（即便不发布，指标值也会通过<code class=\"language-text\">History</code>属性暴露出来），通常可以用来绘图或者进行下一步的操作。</p>\n<div class=\"gatsby-highlight\" data-language=\"c#\"><pre class=\"language-c#\"><code class=\"language-c#\">using TechnicalIndicators;\n// 构造 20 均线\nSimpleMovingAverage iSMA = new SimpleMovingAverage(20);\n// 订阅数据源 (object sender, double data)\nSomeEvent += iSMA.OnInput;\n// 发布指标数据\niSMA.OnOutput += (sender, data) =&gt; {\n  // data is double\n}\n// 引用历史 20 均线数据\niSMA.History[0]; // 第一个均线数据</code></pre></div>\n<blockquote>\n<p> 如果你发现没有合适的订阅数据源，可以运用适配器模式来创建一个数据源适配器。</p>\n</blockquote>\n<p>你的均线基于什么数据完全取决于它订阅了什么，可以是不同周期的市场价格，也可以是其他技术指标。</p>\n<h2>优化的具体思路</h2>\n<p>上面关于简单均线指标的实现的效率并不很高。</p>\n<p><strong>如果你想提升计算速度</strong>，就运用迭代法实现指标。既然保存了数据源的历史数据备份，就可以再维护一份前缀和列表，然后直接在常数时间完成一次指标迭代。这样的做法需要比上述实现多 50 % 的内存消耗。</p>\n<p><strong>如果你想降低内存消耗</strong>，就思考哪些数据是没有必要维护的。我们发现超出均线周期的数据是没有用的，因此我们可以构造固定长度的滑窗(Slide Window)来维护数据源，总的来说内存消耗量比上述实现要低 50 %。</p>\n<p>两种优化思路是不冲突的，只是都会增加一些代码量。</p>\n<p>但无论如何，这对外部引用指标的系统是透明的！你无须更改引用指标的代码便可优化指标的性能。</p>","excerpt":"技术指标泛指一切通过数学公式计算得出的源于 市场数据 的 数据集合 。 这表明技术指标(Technical Indicator)最终都来源于市场数据；技术指标所谓的技术(Technique…"}},"pageContext":{"isCreatedByStatefulCreatePages":false,"type":"posts","next":{"frontmatter":{"path":"/skill-tree-visualization","title":"技能树可视化","tags":["Design"]},"fileAbsolutePath":"C:/Users/zccz14/projects/new-blog/src/posts/2017/01/skill-tree-visualization.md"},"previous":{"frontmatter":{"path":"/distributed-spanning-book","title":"分布式生成书","tags":["Design"]},"fileAbsolutePath":"C:/Users/zccz14/projects/new-blog/src/posts/2017/06/distributed-spanning-book.md"}}}