---
title: 前端综述
date: 2019-01-27
---

"前端" 是人机交互 (HCI: Human Computer Interaction) 的工程侧工作。

从**功能角度**看待前端工作:

交互 (Interaction) = 显示 (Display) + 操纵 (Manipulation)

显示，就是给用户呈现视觉效果，可大方，可精致，可酷炫；
操纵，就是让用户通过用户接口 (UI) 对系统进行操作。

满足功能性需求，是对一个前端工程师最基本的要求；
否则这人根本不 work。

从**技术角度**看待前端工作:

技术就是效率。高级工程师会从很多角度去考虑优化工作效率与系统效率。

为了获得秩序带来的收益，纯粹的技术工作都自觉跟象征混沌的"业务"划清了界限。

从编程与系统两个方面讨论技术性：

编程:

如何优化工程师的工作效率？如何写出更好的代码？

用好设计模式。虽然听起来很高级，但是其实是融入工作的方方面面的，甚至使用设计模式是一件无感知的事情。

> 就好像闭包一样，新手害怕去理解它，但不知不觉中还是到处在用它。

设计模式，或者说设计，催生出了框架与实用工具库。

产品代码 = 框架 + 实用工具 + 业务代码

我们考虑产品代码的业务逻辑本身的复杂度是守恒的，无论你如何编写代码，机器总是要执行同等复杂的指令来达成目标。框架和实用工具的作用就是为了吸收总体的编程复杂度而存在的。框架相比之下更重一些，它能吸收掉很大的复杂度，但它会影响到业务代码的编写方式；而实用工具则不通常不影响业务代码的编写，用也可以，不用也罢，但它能吸收的复杂度比较有限，一般仅用于优化局部代码的编写体验。

着手优化编程体验，提升抽象能力，是工程师迈向 Senior 的开始。

系统:

如何做出更牛逼的系统？

前端系统工程师，更加关注整个系统的非功能性需求的实现，例如错误上报系统，插件系统，构建系统，持续集成等等。
他们将业务无关的东西抽离成一个独立的系统，集成到已有的系统中，来提升系统整体的各种性能。例如错误上报系统就可以有效解决难以对客户端进行直接调试的问题；插件系统可以有效将能力开放给第三方开发者；构建系统通过编译技术有效提升代码的质量。

拥有着前端系统开发能力的工程师通常属于同行中比较 Senior 的。

到了技术层面，前端这个字眼显得不那么重要了，内容也显得老生常谈。
于是现在先抛开技术层面的话题，单纯来讲讲前端的功能层面的内容。

重复一遍: 交互 (Interaction) = 显示 (Display) + 操纵 (Manipulation).

<!--more-->

## 显示 (Display)

现有的前端技术里，对于内容的显示，有如下技术：

1. Element + Style

    利用平台的渲染引擎，定义文档结构与样式，以此呈现内容。

    例如 Web 里的 HTML + CSS，或者 Android 里的 XML Element. 各大平台都不约而同地使用了 XML-like 的树状 Element 描述方式，但有着不同的样式描述方式。

2. CG: Computer Graphics

    利用开放底层的 CG 技术来直接绘制图形。例如 WebGL, OpenGL 等. (WebGL 是 OpenGL 的一种)

说白了，Element + Style 实际上是 CG 技术的一种高级封装。一般情况下能用 Element + Style 解决的问题，不会用 CG 技术去费事。对于特殊的显示需求，例如 Charts, VR, Game 这种需要像素级渲染的东西，才需要动用 CG 技术。

## 操纵 (Manipulation)

介于业务逻辑复杂度的无上限的增长，操纵的难度明显比显示高多了。

很多前端工程师不断学习新的框架，更新技术栈，来使得操纵的开发变得更简单高效。这也是前端饱受诟病的一点，"框架太多了，不知道应该学哪一个，永远在学习"。

在前端领域，操纵是一个复杂的话题。用户会采取各种预期或非预期的动作，系统自身也会产生各种事件。在这种长期的会话中，如何维护状态的正确性，如何正确而快速响应？

相比于后端工程师对各种 case 的小心谨慎，前端工程师的思维似乎更倾向于走 happy path，仅仅考虑用户最正常的操作流程，以及少量的异常情况。我认为其原因是，其一，大量复杂状态与无限的操作序列的叠加使得逻辑路径近乎无限复杂，思考不能；其二，反正无论怎么做，前端只是用户接口，再怎么限制也是能直接 Hack 掉的，只要小心用户的误操作就完事了。

对于原因一的等价问题就是“如何管理前端日渐增长的庞大状态？”。

经过长期的追逐，目前前端三大流行框架: React, Angular, Vue 对于状态的管理实际上大同小异，都是用内部状态完全控制元素的渲染，看来最终的解决方案已经八九不离十了，即将状态管理问题描述为一个状态机，只要为同模型的状态定义好转移方式，然后由框架执行元素的更新。
在正式的前端工作中，要求具有三大框架的开发经验变得越来越普便。三大框架中目前最受欢迎的是 React。

让我们切换到更细微的视角，到模块，到函数，到代码行里行间的编程。

前端程序员大多不太在意片段代码的执行效率，也就是对数据结构与算法具有轻视的心态。这是由于用户作为人类而言，不能处理过多的信息。在前端呈现过多的元素本身就是一件错误的事情。不存在运行效率的优胜劣汰的前端业界，只有大框架彼此在比拼渲染效率。在强大的 JS 执行引擎 V8 出现后，前端程序员写起代码来更是没有后顾之忧了。

但实际上，前端对于性能是有着非常严格的性能要求的，即首屏加载时间(1s内)，以及用户响应时间(200ms内)等。毕竟要给用户一种流畅的使用体验。但这些问题通常并不是代码的执行效率所带来的，而是网络请求的时延带来的问题。因此，各种针对网络的性能优化层出不穷，例如 gzip, sprite, minify, tree shaking, lazy load, network cache, distributed object 等等。都是为了减轻网络负担的优化手段。最后，甚至出现了前端数据库这种东西 (前后端同构应用)。

随着越来越多的算力被分配到了前端设备上，业务在不危害安全与系统可用性的前提下，会尽量地分配到前端，以减轻后端的负载，提升系统整体的效能。甚至在某些 To B 的业务系统中，存在前端业务重得不合理的情况。于是，前端越来越“膨胀”，出现了“大前端”的概念，在 Node.js 出现之后，前端工程师甚至直接把手伸到了后端，一举成为“全栈工程师”。然而这样的“全栈”是伪全栈，因为他们没有点出关于大规模系统运作所需的技能，例如分布式系统，大数据处理，高性能计算等等。

对于前端工程师来说，写代码，更重要的是可维护性，而非性能。相比于后端工程师，前端的业务变动更加频繁，在后端服务化之后，很多新的业务成为了旧的基础业务的组合，这组合的工作自然而然落到了前端工程师的头上。所以前端工程，能看懂几个月前甚至几年前的代码，是非常重要的。对工程师的读代码能力也有着很高的要求。

前端的编程语言 Java Script (正式名为 ECMA Script) 如此灵活，又没有类型，导致它好写却极为难读。对于老代码，不打印出来都不知道这个东西长什么样，只能靠贫乏的命名与很可能不全的文档来猜测。不理解系统的情况下进行开发会埋下诸多 bug。这也成了 Type Script 出现的历史条件。TS 是带有类型标注(Type Annotation) 与类型推导 (Type Inference) 的 JS，其核心的强静态类型系统能有效检查代码中的类型安全问题，在编译期就保证了大多数代码的安全性。这使得 TS 编写的代码的可读性也提升了，TS 具备了大规模系统编写的工程能力。TS 曾经有个竞争对手叫做 Flow，但是现在来看，Flow 已经要凉了。TS 是大势所趋。

不过，TS 仅仅是前端工程化浪潮的一份子，前端的工业革命从 21 世纪 10 年代初才开始，现在依然有非常多的工作可以去做。要积极思考前端的不足之处，主动去完善改良前端的生态，以反哺我们自己的前端工作。
